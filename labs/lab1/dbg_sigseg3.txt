# Prvo cemo da pokrenemo kod i vidimo da li radi.

Starting program: /home/milan/Downloads/RT Programming/sigseg3 

Program received signal SIGSEGV, Segmentation fault.
main (argc=1, argv=0x7fffffffde58) at sigseg3.c:33
33		A[i] = rand()%10;        
# Vidimo da nam se desava Segmentation fault na 33 liniji koda, sada bismo trebali da ucitamo kod i vidimo kako on izgleda te postavimo nekoliko breakpoint-ova. Ucitavanje radimo komandom list.

28		printf("%ld \n", INT_MAX);     
29		int n = INT_MAX;     
30		int A[n];     
31		int i = 0;     
32		while (i<n)       
33		A[i] = rand()%10;        
34		return EXIT_SUCCESS; 
35	}
36	// svrha programa je da alocira niz cjelobrojnih
37	// vrijednosti i inicijalizuje ih slucajnim brojem.
38	// Ali, avaj, segmentation fault se pojavljuje.

# Vidimo da u 30-oj liniji kod generisemo niz intedzera A sa INT_MAX elemenata, sto vrlo vjerovatno premasuje velicinu virtuelne memorije dodjeljenu ovom procesu. Postavicemo breakpoint na 30-u i 33-u liniju koda a zatim postaviti i posmatrace (watch-eve) na promjenljivu A te pokazivace na stek (stack pointer, base pointer). Breakpoint se postavlja komandom break, a posmatrace na promjenljive mozemo postaviti komandom display, ako koristimo display/x prikazujemo adrese datih vrijednosti.

Breakpoint 1 at 0x555555554744: file sigseg3.c, line 30.
Breakpoint 2 at 0x5555555547b0: file sigseg3.c, line 33.
1: /a $sp = 0x7ffdffffdd10
2: /a $bp = 0xffffffffffffdd70
3: /a A = <error: value requires 4294967292 bytes, which is more than max-value-size>
/n# Vidimo da promjenljiva A potrazuje vise memorije nego sto joj je to dozvoljeno te je ovo razlog Segmentation faul-ta, da bismo ovo pokazali pokusacemo joj pratiti adresu a zatim i ispisati je.

4: /x A = <error: value requires 4294967292 bytes, which is more than max-value-size>
value requires 4294967292 bytes, which is more than max-value-size
$1 = void
0x7ffdffffdd10:	Cannot access memory at address 0x7ffdffffdd10
Cannot access memory at address 0x7ffdffffdd10
0x7fffffff:	Cannot access memory at address 0x7fffffff
$2 = 2147483647

 #Komande koje sam kucao su redom display/x A , print A , print $A , x/ A, x/ A[0] ,x/ n te print n. Zatim sam u drugom terminalu kucao komandu ps -ef |grep sigseg3 i pronasao pid ovog procesa, uz pomoc komande cat /proc/pid/maps pogledao raspored memorije i adresa 0x7ffdffffdd10 se nalazi van heap-a u memorijski mapiranom prostoru tik ispod steka.

# Da bismo ovo ponovo testirali pokrenucu jos jednom ovaj program i pratiti uz breakpoint-ove.

Starting program: /home/milan/Downloads/RT Programming/sigseg3 

Breakpoint 1, main (argc=1, argv=0x7fffffffde58) at sigseg3.c:30
30		int A[n];     
1: /a $sp = 0x7fffffffdd10
2: /a $bp = 0xffffffffffffdd70
3: /a A = <error: value requires 63100928 bytes, which is more than max-value-size>
4: /x A = <error: value requires 63100928 bytes, which is more than max-value-size>

 #Da vidimo gdje se nalazimo u kodu, mozemo prikazati asemblersku reprezentaciju instrukcija, komandom disas/s

Dump of assembler code for function main:
sigseg3.c:
27	 int main(int argc, char* argv[]){     
   0x00005555555546fa <+0>:	push   %rbp
   0x00005555555546fb <+1>:	mov    %rsp,%rbp
   0x00005555555546fe <+4>:	push   %r15
   0x0000555555554700 <+6>:	push   %r14
   0x0000555555554702 <+8>:	push   %r13
   0x0000555555554704 <+10>:	push   %r12
   0x0000555555554706 <+12>:	push   %rbx
   0x0000555555554707 <+13>:	sub    $0x38,%rsp
   0x000055555555470b <+17>:	mov    %edi,-0x54(%rbp)
   0x000055555555470e <+20>:	mov    %rsi,-0x60(%rbp)
   0x0000555555554712 <+24>:	mov    %fs:0x28,%rax
   0x000055555555471b <+33>:	mov    %rax,-0x38(%rbp)
   0x000055555555471f <+37>:	xor    %eax,%eax
   0x0000555555554721 <+39>:	mov    %rsp,%rax
   0x0000555555554724 <+42>:	mov    %rax,%rbx

28		printf("%ld \n", INT_MAX);     
   0x0000555555554727 <+45>:	mov    $0x7fffffff,%esi
   0x000055555555472c <+50>:	lea    0x171(%rip),%rdi        # 0x5555555548a4
   0x0000555555554733 <+57>:	mov    $0x0,%eax
   0x0000555555554738 <+62>:	callq  0x5555555545c0 <printf@plt>

29		int n = INT_MAX;     
   0x000055555555473d <+67>:	movl   $0x7fffffff,-0x50(%rbp)

30		int A[n];     
=> 0x0000555555554744 <+74>:	mov    -0x50(%rbp),%eax
   0x0000555555554747 <+77>:	movslq %eax,%rdx
   0x000055555555474a <+80>:	sub    $0x1,%rdx
   0x000055555555474e <+84>:	mov    %rdx,-0x48(%rbp)
   0x0000555555554752 <+88>:	movslq %eax,%rdx
   0x0000555555554755 <+91>:	mov    %rdx,%r14
   0x0000555555554758 <+94>:	mov    $0x0,%r15d
   0x000055555555475e <+100>:	movslq %eax,%rdx
   0x0000555555554761 <+103>:	mov    %rdx,%r12
   0x0000555555554764 <+106>:	mov    $0x0,%r13d
   0x000055555555476a <+112>:	cltq   
   0x000055555555476c <+114>:	shl    $0x2,%rax
   0x0000555555554770 <+118>:	lea    0x3(%rax),%rdx
   0x0000555555554774 <+122>:	mov    $0x10,%eax
   0x0000555555554779 <+127>:	sub    $0x1,%rax
   0x000055555555477d <+131>:	add    %rdx,%rax
   0x0000555555554780 <+134>:	mov    $0x10,%edi
   0x0000555555554785 <+139>:	mov    $0x0,%edx
   0x000055555555478a <+144>:	div    %rdi
   0x000055555555478d <+147>:	imul   $0x10,%rax,%rax
   0x0000555555554791 <+151>:	sub    %rax,%rsp
   0x0000555555554794 <+154>:	mov    %rsp,%rax
   0x0000555555554797 <+157>:	add    $0x3,%rax
   0x000055555555479b <+161>:	shr    $0x2,%rax
   0x000055555555479f <+165>:	shl    $0x2,%rax
   0x00005555555547a3 <+169>:	mov    %rax,-0x40(%rbp)

31		int i = 0;     
   0x00005555555547a7 <+173>:	movl   $0x0,-0x4c(%rbp)

32		while (i<n)       
   0x00005555555547ae <+180>:	jmp    0x5555555547e4 <main+234>

33		A[i] = rand()%10;        
   0x00005555555547b0 <+182>:	callq  0x5555555545d0 <rand@plt>
   0x00005555555547b5 <+187>:	mov    %eax,%ecx
   0x00005555555547b7 <+189>:	mov    $0x66666667,%edx
   0x00005555555547bc <+194>:	mov    %ecx,%eax
   0x00005555555547be <+196>:	imul   %edx
   0x00005555555547c0 <+198>:	sar    $0x2,%edx
   0x00005555555547c3 <+201>:	mov    %ecx,%eax
   0x00005555555547c5 <+203>:	sar    $0x1f,%eax
   0x00005555555547c8 <+206>:	sub    %eax,%edx
   0x00005555555547ca <+208>:	mov    %edx,%eax
   0x00005555555547cc <+210>:	shl    $0x2,%eax
   0x00005555555547cf <+213>:	add    %edx,%eax
   0x00005555555547d1 <+215>:	add    %eax,%eax
   0x00005555555547d3 <+217>:	sub    %eax,%ecx
   0x00005555555547d5 <+219>:	mov    %ecx,%edx
   0x00005555555547d7 <+221>:	mov    -0x40(%rbp),%rax
   0x00005555555547db <+225>:	mov    -0x4c(%rbp),%ecx
   0x00005555555547de <+228>:	movslq %ecx,%rcx
   0x00005555555547e1 <+231>:	mov    %edx,(%rax,%rcx,4)

32		while (i<n)       
   0x00005555555547e4 <+234>:	mov    -0x4c(%rbp),%eax
   0x00005555555547e7 <+237>:	cmp    -0x50(%rbp),%eax
   0x00005555555547ea <+240>:	jl     0x5555555547b0 <main+182>

34		return EXIT_SUCCESS; 
   0x00005555555547ec <+242>:	mov    $0x0,%eax
   0x00005555555547f1 <+247>:	mov    %rbx,%rsp

35	}
   0x00005555555547f4 <+250>:	mov    -0x38(%rbp),%rsi
   0x00005555555547f8 <+254>:	xor    %fs:0x28,%rsi
   0x0000555555554801 <+263>:	je     0x555555554808 <main+270>
   0x0000555555554803 <+265>:	callq  0x5555555545b0 <__stack_chk_fail@plt>
   0x0000555555554808 <+270>:	lea    -0x28(%rbp),%rsp
   0x000055555555480c <+274>:	pop    %rbx
   0x000055555555480d <+275>:	pop    %r12
   0x000055555555480f <+277>:	pop    %r13
   0x0000555555554811 <+279>:	pop    %r14
   0x0000555555554813 <+281>:	pop    %r15
   0x0000555555554815 <+283>:	pop    %rbp
   0x0000555555554816 <+284>:	retq   
End of assembler dump.

 #Nastavljamo dalje do iduceg breakpointa.

Continuing.

Breakpoint 2, main (argc=1, argv=0x7fffffffde58) at sigseg3.c:33
33		A[i] = rand()%10;        
1: /a $sp = 0x7ffdffffdd10
2: /a $bp = 0xffffffffffffdd70
3: /a A = <error: value requires 4294967292 bytes, which is more than max-value-size>
4: /x A = <error: value requires 4294967292 bytes, which is more than max-value-size>

 # Ponovo posmatramo asemblersku reprezentaciju koda:

Dump of assembler code for function main:
sigseg3.c:
27	 int main(int argc, char* argv[]){     
   0x00005555555546fa <+0>:	push   %rbp
   0x00005555555546fb <+1>:	mov    %rsp,%rbp
   0x00005555555546fe <+4>:	push   %r15
   0x0000555555554700 <+6>:	push   %r14
   0x0000555555554702 <+8>:	push   %r13
   0x0000555555554704 <+10>:	push   %r12
   0x0000555555554706 <+12>:	push   %rbx
   0x0000555555554707 <+13>:	sub    $0x38,%rsp
   0x000055555555470b <+17>:	mov    %edi,-0x54(%rbp)
   0x000055555555470e <+20>:	mov    %rsi,-0x60(%rbp)
   0x0000555555554712 <+24>:	mov    %fs:0x28,%rax
   0x000055555555471b <+33>:	mov    %rax,-0x38(%rbp)
   0x000055555555471f <+37>:	xor    %eax,%eax
   0x0000555555554721 <+39>:	mov    %rsp,%rax
   0x0000555555554724 <+42>:	mov    %rax,%rbx

28		printf("%ld \n", INT_MAX);     
   0x0000555555554727 <+45>:	mov    $0x7fffffff,%esi
   0x000055555555472c <+50>:	lea    0x171(%rip),%rdi        # 0x5555555548a4
   0x0000555555554733 <+57>:	mov    $0x0,%eax
   0x0000555555554738 <+62>:	callq  0x5555555545c0 <printf@plt>

29		int n = INT_MAX;     
   0x000055555555473d <+67>:	movl   $0x7fffffff,-0x50(%rbp)

30		int A[n];     
   0x0000555555554744 <+74>:	mov    -0x50(%rbp),%eax
   0x0000555555554747 <+77>:	movslq %eax,%rdx
   0x000055555555474a <+80>:	sub    $0x1,%rdx
   0x000055555555474e <+84>:	mov    %rdx,-0x48(%rbp)
   0x0000555555554752 <+88>:	movslq %eax,%rdx
   0x0000555555554755 <+91>:	mov    %rdx,%r14
   0x0000555555554758 <+94>:	mov    $0x0,%r15d
   0x000055555555475e <+100>:	movslq %eax,%rdx
   0x0000555555554761 <+103>:	mov    %rdx,%r12
   0x0000555555554764 <+106>:	mov    $0x0,%r13d
   0x000055555555476a <+112>:	cltq   
   0x000055555555476c <+114>:	shl    $0x2,%rax
   0x0000555555554770 <+118>:	lea    0x3(%rax),%rdx
   0x0000555555554774 <+122>:	mov    $0x10,%eax
   0x0000555555554779 <+127>:	sub    $0x1,%rax
   0x000055555555477d <+131>:	add    %rdx,%rax
   0x0000555555554780 <+134>:	mov    $0x10,%edi
   0x0000555555554785 <+139>:	mov    $0x0,%edx
   0x000055555555478a <+144>:	div    %rdi
   0x000055555555478d <+147>:	imul   $0x10,%rax,%rax
   0x0000555555554791 <+151>:	sub    %rax,%rsp
   0x0000555555554794 <+154>:	mov    %rsp,%rax
   0x0000555555554797 <+157>:	add    $0x3,%rax
   0x000055555555479b <+161>:	shr    $0x2,%rax
   0x000055555555479f <+165>:	shl    $0x2,%rax
   0x00005555555547a3 <+169>:	mov    %rax,-0x40(%rbp)

31		int i = 0;     
   0x00005555555547a7 <+173>:	movl   $0x0,-0x4c(%rbp)

32		while (i<n)       
   0x00005555555547ae <+180>:	jmp    0x5555555547e4 <main+234>

33		A[i] = rand()%10;        
=> 0x00005555555547b0 <+182>:	callq  0x5555555545d0 <rand@plt>
   0x00005555555547b5 <+187>:	mov    %eax,%ecx
   0x00005555555547b7 <+189>:	mov    $0x66666667,%edx
   0x00005555555547bc <+194>:	mov    %ecx,%eax
   0x00005555555547be <+196>:	imul   %edx
   0x00005555555547c0 <+198>:	sar    $0x2,%edx
   0x00005555555547c3 <+201>:	mov    %ecx,%eax
   0x00005555555547c5 <+203>:	sar    $0x1f,%eax
   0x00005555555547c8 <+206>:	sub    %eax,%edx
   0x00005555555547ca <+208>:	mov    %edx,%eax
   0x00005555555547cc <+210>:	shl    $0x2,%eax
   0x00005555555547cf <+213>:	add    %edx,%eax
   0x00005555555547d1 <+215>:	add    %eax,%eax
   0x00005555555547d3 <+217>:	sub    %eax,%ecx
   0x00005555555547d5 <+219>:	mov    %ecx,%edx
   0x00005555555547d7 <+221>:	mov    -0x40(%rbp),%rax
   0x00005555555547db <+225>:	mov    -0x4c(%rbp),%ecx
   0x00005555555547de <+228>:	movslq %ecx,%rcx
   0x00005555555547e1 <+231>:	mov    %edx,(%rax,%rcx,4)

32		while (i<n)       
   0x00005555555547e4 <+234>:	mov    -0x4c(%rbp),%eax
   0x00005555555547e7 <+237>:	cmp    -0x50(%rbp),%eax
   0x00005555555547ea <+240>:	jl     0x5555555547b0 <main+182>

34		return EXIT_SUCCESS; 
   0x00005555555547ec <+242>:	mov    $0x0,%eax
   0x00005555555547f1 <+247>:	mov    %rbx,%rsp

35	}
   0x00005555555547f4 <+250>:	mov    -0x38(%rbp),%rsi
   0x00005555555547f8 <+254>:	xor    %fs:0x28,%rsi
   0x0000555555554801 <+263>:	je     0x555555554808 <main+270>
   0x0000555555554803 <+265>:	callq  0x5555555545b0 <__stack_chk_fail@plt>
   0x0000555555554808 <+270>:	lea    -0x28(%rbp),%rsp
   0x000055555555480c <+274>:	pop    %rbx
   0x000055555555480d <+275>:	pop    %r12
   0x000055555555480f <+277>:	pop    %r13
   0x0000555555554811 <+279>:	pop    %r14
   0x0000555555554813 <+281>:	pop    %r15
   0x0000555555554815 <+283>:	pop    %rbp
   0x0000555555554816 <+284>:	retq   
End of assembler dump.

 #Ispisacemo adresu pocetka niza i sa stepi pokusati uskociti u iducu instrukciju.

0x7ffdffffdd10:	Cannot access memory at address 0x7ffdffffdd10

Program received signal SIGSEGV, Segmentation fault.
main (argc=1, argv=0x7fffffffde58) at sigseg3.c:33
33		A[i] = rand()%10;        
1: /a $sp = 0x7ffdffffdd10
2: /a $bp = 0xffffffffffffdd70
3: /a A = <error: value requires 4294967292 bytes, which is more than max-value-size>
4: /x A = <error: value requires 4294967292 bytes, which is more than max-value-size>

Dump of assembler code for function main:
sigseg3.c:
27	 int main(int argc, char* argv[]){     
   0x00005555555546fa <+0>:	push   %rbp
   0x00005555555546fb <+1>:	mov    %rsp,%rbp
   0x00005555555546fe <+4>:	push   %r15
   0x0000555555554700 <+6>:	push   %r14
   0x0000555555554702 <+8>:	push   %r13
   0x0000555555554704 <+10>:	push   %r12
   0x0000555555554706 <+12>:	push   %rbx
   0x0000555555554707 <+13>:	sub    $0x38,%rsp
   0x000055555555470b <+17>:	mov    %edi,-0x54(%rbp)
   0x000055555555470e <+20>:	mov    %rsi,-0x60(%rbp)
   0x0000555555554712 <+24>:	mov    %fs:0x28,%rax
   0x000055555555471b <+33>:	mov    %rax,-0x38(%rbp)
   0x000055555555471f <+37>:	xor    %eax,%eax
   0x0000555555554721 <+39>:	mov    %rsp,%rax
   0x0000555555554724 <+42>:	mov    %rax,%rbx

28		printf("%ld \n", INT_MAX);     
   0x0000555555554727 <+45>:	mov    $0x7fffffff,%esi
   0x000055555555472c <+50>:	lea    0x171(%rip),%rdi        # 0x5555555548a4
   0x0000555555554733 <+57>:	mov    $0x0,%eax
   0x0000555555554738 <+62>:	callq  0x5555555545c0 <printf@plt>

29		int n = INT_MAX;     
   0x000055555555473d <+67>:	movl   $0x7fffffff,-0x50(%rbp)

30		int A[n];     
   0x0000555555554744 <+74>:	mov    -0x50(%rbp),%eax
   0x0000555555554747 <+77>:	movslq %eax,%rdx
   0x000055555555474a <+80>:	sub    $0x1,%rdx
   0x000055555555474e <+84>:	mov    %rdx,-0x48(%rbp)
   0x0000555555554752 <+88>:	movslq %eax,%rdx
   0x0000555555554755 <+91>:	mov    %rdx,%r14
   0x0000555555554758 <+94>:	mov    $0x0,%r15d
   0x000055555555475e <+100>:	movslq %eax,%rdx
   0x0000555555554761 <+103>:	mov    %rdx,%r12
   0x0000555555554764 <+106>:	mov    $0x0,%r13d
   0x000055555555476a <+112>:	cltq   
   0x000055555555476c <+114>:	shl    $0x2,%rax
   0x0000555555554770 <+118>:	lea    0x3(%rax),%rdx
   0x0000555555554774 <+122>:	mov    $0x10,%eax
   0x0000555555554779 <+127>:	sub    $0x1,%rax
   0x000055555555477d <+131>:	add    %rdx,%rax
   0x0000555555554780 <+134>:	mov    $0x10,%edi
   0x0000555555554785 <+139>:	mov    $0x0,%edx
   0x000055555555478a <+144>:	div    %rdi
   0x000055555555478d <+147>:	imul   $0x10,%rax,%rax
   0x0000555555554791 <+151>:	sub    %rax,%rsp
   0x0000555555554794 <+154>:	mov    %rsp,%rax
   0x0000555555554797 <+157>:	add    $0x3,%rax
   0x000055555555479b <+161>:	shr    $0x2,%rax
   0x000055555555479f <+165>:	shl    $0x2,%rax
   0x00005555555547a3 <+169>:	mov    %rax,-0x40(%rbp)

31		int i = 0;     
   0x00005555555547a7 <+173>:	movl   $0x0,-0x4c(%rbp)

32		while (i<n)       
   0x00005555555547ae <+180>:	jmp    0x5555555547e4 <main+234>

33		A[i] = rand()%10;        
=> 0x00005555555547b0 <+182>:	callq  0x5555555545d0 <rand@plt>
   0x00005555555547b5 <+187>:	mov    %eax,%ecx
   0x00005555555547b7 <+189>:	mov    $0x66666667,%edx
   0x00005555555547bc <+194>:	mov    %ecx,%eax
   0x00005555555547be <+196>:	imul   %edx
   0x00005555555547c0 <+198>:	sar    $0x2,%edx
   0x00005555555547c3 <+201>:	mov    %ecx,%eax
   0x00005555555547c5 <+203>:	sar    $0x1f,%eax
   0x00005555555547c8 <+206>:	sub    %eax,%edx
   0x00005555555547ca <+208>:	mov    %edx,%eax
   0x00005555555547cc <+210>:	shl    $0x2,%eax
   0x00005555555547cf <+213>:	add    %edx,%eax
   0x00005555555547d1 <+215>:	add    %eax,%eax
   0x00005555555547d3 <+217>:	sub    %eax,%ecx
   0x00005555555547d5 <+219>:	mov    %ecx,%edx
   0x00005555555547d7 <+221>:	mov    -0x40(%rbp),%rax
   0x00005555555547db <+225>:	mov    -0x4c(%rbp),%ecx
   0x00005555555547de <+228>:	movslq %ecx,%rcx
   0x00005555555547e1 <+231>:	mov    %edx,(%rax,%rcx,4)

32		while (i<n)       
   0x00005555555547e4 <+234>:	mov    -0x4c(%rbp),%eax
   0x00005555555547e7 <+237>:	cmp    -0x50(%rbp),%eax
   0x00005555555547ea <+240>:	jl     0x5555555547b0 <main+182>

34		return EXIT_SUCCESS; 
   0x00005555555547ec <+242>:	mov    $0x0,%eax
   0x00005555555547f1 <+247>:	mov    %rbx,%rsp

35	}
   0x00005555555547f4 <+250>:	mov    -0x38(%rbp),%rsi
   0x00005555555547f8 <+254>:	xor    %fs:0x28,%rsi
   0x0000555555554801 <+263>:	je     0x555555554808 <main+270>
   0x0000555555554803 <+265>:	callq  0x5555555545b0 <__stack_chk_fail@plt>
   0x0000555555554808 <+270>:	lea    -0x28(%rbp),%rsp
   0x000055555555480c <+274>:	pop    %rbx
   0x000055555555480d <+275>:	pop    %r12
   0x000055555555480f <+277>:	pop    %r13
   0x0000555555554811 <+279>:	pop    %r14
   0x0000555555554813 <+281>:	pop    %r15
   0x0000555555554815 <+283>:	pop    %rbp
   0x0000555555554816 <+284>:	retq   
End of assembler dump.

Program terminated with signal SIGSEGV, Segmentation fault.
The program no longer exists.
No frame selected.
